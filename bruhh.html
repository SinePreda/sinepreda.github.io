<!DOCTYPE html>
<html>
<head>
<title>CLAIM OF POLICY</title>
<meta charset="UTF-8">
<meta name="description" content="ang bango bango ng roses">
<meta name="author" content="SinePreda">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    font-family: sans-serif;
    color: white;
    background-color: #15083b;
    animation: bodycolor 7s infinite;
}
@keyframes bodycolor {
  0% {background-color: #15083b}
  50% {background-color: #121b72}
  100% {background-color: #15083b}
}
canvas {
    opacity: 0;
    transition: all 0.6s;
    width: 50%;
    height: 100%;
    position: fixed;
    top: 0;
    right: -70%;
}
h1, h2 {
    text-decoration: underline;
}
h1 {
    text-align: center;
    transition: all 0.5s;
    opacity: 0;
}
h1:hover {
  color: gray;
}
h2, p {
    padding-left: 10px;
}
iframe {
    padding-left: 15px;
    opacity: 0;
    transition: all 0.4s;
}
p {
  transition: all 0.2s;
  max-width: 40%;
  padding: 7px;
  opacity: 0;
  border-radius: 5px;
}
p:hover {
  background: rgb(218, 218, 218);
  color: black;
}
::-webkit-scrollbar {width:15px;}
::-webkit-scrollbar-track {background:black}
::-webkit-scrollbar-thumb {background:#ffffff;}
.tooltip, .tooltipb, .tooltipc, .tooltipd {
  position: relative;
  display: inline-block;
}
.tooltip .tooltiptext, .tooltipb .tooltiptextb, .tooltipc .tooltiptextc, .tooltipd .tooltiptextd {
  visibility: hidden;
  width: 120px;
  background-color: black;
  color: #fff;
  border-radius: 6px;
  padding: 5px;
  position: absolute;
  z-index: 1;
  top: 100%;
  left: 50%;
  margin-left: -60px;
}
.tooltip:hover .tooltiptext, .tooltipb:hover .tooltiptextb, .tooltipc:hover .tooltiptextc, .tooltipd:hover .tooltiptextd {
  visibility: visible;
}
</style>
</head>
<body>
<h1>CLAIM OF POLICY</h1>
<div class="tooltip"><h2></h2>
  <span class="tooltiptext">The simplified description for what a Claim of Policy is.</span>
</div>
<p></p>
<div class="tooltipb"><h2></h2>
  <span class="tooltiptextb">The basic characteristics for a Claim of Policy.</span>
</div>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<div class="tooltipc"><h2></h2>
  <span class="tooltiptextc">Attributes you need in defending a Claim of Policy.</span>
</div>
<p></p>
<p></p>
<p></p>
<div class="tooltipd"><h2></h2>
  <span class="tooltiptextd">Examples of Claims of Policy.</span>
</div>
<p></p>
<p></p>
<p></p>
<iframe width="420" height="315" src="https://www.youtube.com/embed/fPUaiRyf_Kk"></iframe>

<script>
var h2texts = [
    "DEFINITION", "CHARACTERISTICS", "DEFENDING A CLAIM", "EXAMPLES"
];
var ptexts = [
    "- A claim in argument form asserting policies or conditions that should be existent.",
    "- Usually implies solution.",
    "- Usage of the words 'ought to', 'must' and 'should'.",
    "- Involves sub claims of facts and values.",
    "- Data shows benefit of plan.",
    "- Usually procedural.",
    "- Based on facts.",
    "- Backed up by values.",
    "- Shows how the solution can solve the problem.",
    "The death penalty should be abolished because it does nothing to prevent murder.",
    "Legislation should be passed to stop the sales of cigarettes to avoid further respiratory diseases.",
    "The age at which people can get a driver's license must be raised to 18 to ensure responsibility of the driver."
];
var ih2 = [0, 0, 0, 0];
var typingSpeed = 40, animDelay = 800;
function gTag(tag) {return document.getElementsByTagName(tag);}
function oBlock(tag, n) {gTag(tag)[n].style.opacity = 1;}
function typeH21() {
    if (ih2[0] < h2texts[0].length) {
        gTag("h2")[0].innerHTML += h2texts[0].charAt(ih2[0]);
        ih2[0]++;
        setTimeout(typeH21, typingSpeed);
    }
}
function typeH22() {
    if (ih2[1] < h2texts[1].length) {
        gTag("h2")[1].innerHTML += h2texts[1].charAt(ih2[1]);
        ih2[1]++;
        setTimeout(typeH22, typingSpeed);
    }
}
function typeH23() {
    if (ih2[2] < h2texts[2].length) {
        gTag("h2")[2].innerHTML += h2texts[2].charAt(ih2[2]);
        ih2[2]++;
        setTimeout(typeH23, typingSpeed);
    }
}
function typeH24() {
    if (ih2[3] < h2texts[3].length) {
        gTag("h2")[3].innerHTML += h2texts[3].charAt(ih2[3]);
        ih2[3]++;
        setTimeout(typeH24, typingSpeed);
    }
}
function firstAnim() {
    oBlock("h1", 0);
    setTimeout(secondAnim, animDelay);
}
function secondAnim() {
    typeH21();
    setTimeout(typeH22, 300);
    setTimeout(typeH23, 600);
    setTimeout(typeH24, 900);
    setTimeout(function(){
      var ps = gTag("p");
      for (var i = 0; i < ps.length; i++) {
        oBlock("p", i);
      }
    }, 1500);
    setTimeout(thirdAnim, animDelay + 700);
}
function thirdAnim() {
    setTimeout(function(){gTag("p")[0].innerHTML = ptexts[0];}, 100);
    setTimeout(function(){gTag("p")[1].innerHTML = ptexts[1];}, 200);
    setTimeout(function(){gTag("p")[2].innerHTML = ptexts[2];}, 300);
    setTimeout(function(){gTag("p")[3].innerHTML = ptexts[3];}, 400);
    setTimeout(function(){gTag("p")[4].innerHTML = ptexts[4];}, 500);
    setTimeout(function(){gTag("p")[5].innerHTML = ptexts[5];}, 600);
    setTimeout(function(){gTag("p")[6].innerHTML = ptexts[6];}, 700);
    setTimeout(function(){gTag("p")[7].innerHTML = ptexts[7];}, 800);
    setTimeout(function(){gTag("p")[8].innerHTML = ptexts[8];}, 900);
    setTimeout(function(){gTag("p")[9].innerHTML = ptexts[9];}, 1000);
    setTimeout(function(){gTag("p")[10].innerHTML = ptexts[10];}, 1100);
    setTimeout(function(){gTag("p")[11].innerHTML = ptexts[11];}, 1200);
    setTimeout(function(){oBlock("canvas", 0); oBlock("iframe", 0)}, 1500);
    setTimeout(function(){gTag("canvas")[0].style.right = "0";}, 2000);
}
setTimeout(firstAnim, animDelay);
</script>
<canvas id="cnv" width="800" height="600"></canvas>
<script>
var Vertex = function(x, y, z) {
  this.x = parseFloat(x);
  this.y = parseFloat(y);
  this.z = parseFloat(z);
};

var Vertex2D = function(x, y) {
  this.x = parseFloat(x);
  this.y = parseFloat(y);
};

var Cube = function(center, side) {
  // Generate the vertices
  var d = side / 2;

  this.vertices = [
        new Vertex(center.x - d, center.y - d, center.z + d),
        new Vertex(center.x - d, center.y - d, center.z - d),
        new Vertex(center.x + d, center.y - d, center.z - d),
        new Vertex(center.x + d, center.y - d, center.z + d),
        new Vertex(center.x + d, center.y + d, center.z + d),
        new Vertex(center.x + d, center.y + d, center.z - d),
        new Vertex(center.x - d, center.y + d, center.z - d),
        new Vertex(center.x - d, center.y + d, center.z + d)
  ];

  // Generate the faces
  this.faces = [
    [this.vertices[0], this.vertices[1], this.vertices[2], this.vertices[3]],
        [this.vertices[3], this.vertices[2], this.vertices[5], this.vertices[4]],
        [this.vertices[4], this.vertices[5], this.vertices[6], this.vertices[7]],
        [this.vertices[7], this.vertices[6], this.vertices[1], this.vertices[0]],
        [this.vertices[7], this.vertices[0], this.vertices[3], this.vertices[4]],
        [this.vertices[1], this.vertices[6], this.vertices[5], this.vertices[2]]
  ];
};

function project(M) {
  // Distance between the camera and the plane
  var d = 150;
  var r = d / M.y;

  return new Vertex2D(r * M.x, r * M.z);
}

function render(objects, ctx, dx, dy) {
  // Clear the previous frame
  ctx.clearRect(0, 0, 2*dx, 2*dy);

  // For each object
  for (var i = 0, n_obj = objects.length; i < n_obj; ++i) {
    // For each face
    for (var j = 0, n_faces = objects[i].faces.length; j < n_faces; ++j) {
      // Current face
      var face = objects[i].faces[j];

      // Draw the first vertex
      var P = project(face[0]);
      ctx.beginPath();
      ctx.moveTo(P.x + dx, -P.y + dy);

      // Draw the other vertices
      for (var k = 1, n_vertices = face.length; k < n_vertices; ++k) {
        P = project(face[k]);
        ctx.lineTo(P.x + dx, -P.y + dy);
      }

      // Close the path and draw the face
      ctx.closePath();
      ctx.stroke();
      ctx.fill();
    }
  }
}

(function() {
  // Fix the canvas width and height
  var canvas = document.getElementById('cnv');
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
  var dx = canvas.width / 2;
  var dy = canvas.height / 2;

  // Objects style
  var ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
  ctx.fillStyle = 'rgba(50, 150, 255, 0.2)';

  // Create the cube
  var cube_center = new Vertex(0, 11*dy/10, 0);
  var cube = new Cube(cube_center, dy);
  var objects = [cube];

  // First render
  render(objects, ctx, dx, dy);

  // Events
  var mousedown = false;
  var mx = 0;
  var my = 0;

  canvas.addEventListener('mousedown', initMove);
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', stopMove);

  // Rotate a vertice
  function rotate(M, center, theta, phi) {
        // Rotation matrix coefficients
      var ct = Math.cos(theta);
      var st = Math.sin(theta);
      var cp = Math.cos(phi);
      var sp = Math.sin(phi);

    // Rotation
    var x = M.x - center.x;
    var y = M.y - center.y;
    var z = M.z - center.z;

    M.x = ct * x - st * cp * y + st * sp * z + center.x;
    M.y = st * x + ct * cp * y - ct * sp * z + center.y;
    M.z = sp * y + cp * z + center.z;
  }

  // Initialize the movement
  function initMove(evt) {
    clearTimeout(autorotate_timeout);
    mousedown = true;
    mx = evt.clientX;
    my = evt.clientY;
  }

  function move(evt) {
    if (mousedown) {
      var theta = (evt.clientX - mx) * Math.PI / 360;
      var phi = (evt.clientY - my) * Math.PI / 180;

      for (var i = 0; i < 8; ++i)
        rotate(cube.vertices[i], cube_center, theta, phi);

      mx = evt.clientX;
      my = evt.clientY;

      render(objects, ctx, dx, dy);
    }
  }

  function stopMove() {
    mousedown = false;
    autorotate_timeout = setTimeout(autorotate, 3000);
  }

  function autorotate() {
    for (var i = 0; i < 8; ++i)
      rotate(cube.vertices[i], cube_center, -Math.PI / 720, Math.PI / 700);

    render(objects, ctx, dx, dy);

    autorotate_timeout = setTimeout(autorotate, 30);
  }
  autorotate_timeout = setTimeout(autorotate, 3000);
})();
</script>
</body>
</html>
